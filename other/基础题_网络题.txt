
第一 TCP/IP
    https://www.cnblogs.com/foremostxl/p/9650431.html
    TCP/IP五层协议
    物理层--数据链路层--网络层--传输层--应用层

    七层 传输层和应用层之间，有会话层和表示层

    物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0，设备：电缆、光缆等

    数据链路层(以太网协议)的功能：定义了电信号的分组方式，每一帧数据分成：报头head和数据data两部分

       head包含：
         发送者mac地址
         接受者mac地址
         数据类型
       data包含：
        数据包的具体内容
    mac地址：网卡的地址(每块网卡出厂时都被烧制上一个世界唯一的mac地址)，以太网协议规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址
    
       有了mac地址，同一网络内的两台主机就可以通信了,以太网协议采用最原始的方式，广播的方式进行通信.

    网络层（ip协议）
       
       网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址,
            子网掩码：将ip地址分为网络地址和主机地址,区分网络位和主机位是为了划分子网，把一个大网络分成多个小网络,避免广播风暴和地址浪费

       就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关,于是就有了子网掩码
   
    传输层（建立端口到端口的通信tcp/udp）

       传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，迅雷等多个应用程序，
      
       那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序呢？答案就是端口，端口即应用程序与网卡关联的   编号

       传输层功能：建立端口到端口的通信

       tcp协议，tcp的3次握手和4次挥手 

    应用层:http请求


第二、App网络层有哪些优化策略？
     
     网络层的优化手段主要从以下三方面考虑：
          针对链接建立环节的优化
          针对链接传输数据量的优化
          针对链接复用的优化

   1. 针对链接建立环节的优化
      在API发起请求建立链接的环节，大致会分这些步骤：
        发起请求
        DNS域名解析得到IP
        根据IP进行三次握手（HTTPS四次握手），链接建立成功

      1.1 针对发起请求的优化手段

          其实要解决的问题就是网络层该不该为此API调用发起请求
          1.1.1 使用缓存手段减少请求的发起次数，比如有些API请求所带来的数据的时效性是比较长的
          1.1.2 使用策略来减少请求的发起次数    比如快速重复请求事件处理
          小总结
           针对建立连接这部分的优化就是这样的原则：能不发请求的就尽量不发请求，必须要发请求时，能合并请求的就尽量合并请求。然而，任何优化手段都是有前提的，
           而且也不能保证对所有需求都能起作用，有些API请求就是不符合这些优化手段前提的，那就老老实实发请求吧。不过这类API请求所占比例一般不大，大部分的请求都或多或少符合优化条件，
           所以针对发送请求的优化手段还是值得做的。

      1.2 & 1.3 针对DNS域名解析做的优化，以及建立链接的优化

           1、API请求在DNS解析阶段的耗时会很多，索性直接走IP请求，那不就绕过DNS服务的耗时了嘛
           2、建立链接时候的第三步，国内的网络环境分北网通南电信（当然实际情况更复杂，这里随便说说），不同服务商之间的连接，延时是很大的，
              案就应该是这样：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，
              然后取延时时间最小的那个IP作为今后发起请求的IP地址，所以需要维护一个IP列表，这样就能就近连接了，就起到了优化的效果


    2. 针对链接传输数据量的优化


       这个很好理解，传输的数据少了，那么自然速度就上去了。这里没什么花样可以讲的，就是压缩呗。各种压缩

    3. 针对链接复用的优化
         建立链接本身是属于比较消耗资源的操作，耗电耗时。建议最好是用SPDY（自带链接复用以及数据压缩的功能），SPDY和pipeline虽然都属于链接复用的范畴，但是pipeline并不是真正意义上的链接复用，SPDY的链接复用相对pipeline而言更为彻底。
         SPDY目前也有现成的客户端SDK可以使用。
         
  网络传输和网络用户体验方面优化
         1）  传输文件用数据量小的json 或者protocol buffer,减少压缩网络数据
         2)    如果多次请求结果是相同，尽量使用缓存；
         3） 让用户可以取消耗时长的或者速度很慢的网络操作，设置合适的超时时间；
         4） 网络不可用时，不要尝试执行网络请求；
         5） 使用断点续传，否则网络不稳定时可能多次传输相同的内容；
         6） 批量传输，比如下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块的下载

第三、对称加密和非对称加密的区别？分别有哪些算法的实现
     https://www.cnblogs.com/labimeilexin/p/7350448.html

     1、对称加密：加密解密用同一个密钥，被黑客拦截不安全，使用起来简单快捷，密钥较短，AES
        速度高，可加密内容较大，用来加密会话过程中的消息

     2、非对称加密：公钥加密，私钥解密；公钥可以公开给别人进行加密，私钥永远在自己手里，非常安全，黑客拦截也没用，因为私钥未公开。著名的RSA加密算法用的就是非对称加密
        加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥

第五、HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？
     https://blog.csdn.net/superviser3000/article/details/80812263?utm_source=blogxgwz0
     Http 超文本传输协议，HTTP协议传输的数据都是未加密的，也就是明文的
     Https 安全的超文本传输协议，SSL协议用于对Http协议传输的数据进行加密

     SSL协议加密方式

        SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，
        链路建立好之后，SSL对传输内容使用对称加密。

    Https在建立Socket连接之前，需要进行握手，单向认证具体过程如下：

        1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
        2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
        3、客户端使用服务端返回的信息验证服务器的合法性，包括：

             证书是否过期
             发行服务器证书的CA是否可靠
             返回的公钥是否能正确解开返回证书中的数字签名
             服务器证书上的域名是否和服务器的实际域名相匹配
             验证通过后，将继续进行通信，否则，终止通信

        4、客户端向服务端发送自己所能支持的非对称加密方案，供服务器端进行选择
        5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。
        6、服务器将选择好的加密方案通过明文方式返回给客户端
        7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器
        8、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，
           保证通信过程中信息的安全

    双向认证

       双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：

         1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
         2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
         3、客户端使用服务端返回的信息验证服务器的合法性，包括：

              证书是否过期
              发行服务器证书的CA是否可靠
              返回的公钥是否能正确解开返回证书中的数字签名
              服务器证书上的域名是否和服务器的实际域名相匹配
              验证通过后，将继续进行通信，否则，终止通信

        4、服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端
        5、验证客户端的证书，通过验证后，会获得客户端的公钥
        6、客户端向服务端发送自己所能支持的非对称加密方案，供服务器端进行选择
        7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式
        8、将加密方案通过使用之前获取到的公钥进行加密，返回给客户端
    9、客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端
        10、服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。


第六、HTTPS是如何实现验证身份和验证完整性的？
     https://blog.csdn.net/wx_962464/article/details/51043069
     数字签名技术
        就是对“非对称密钥加解密”和“数字摘要“两项技术的应用，它将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，
        然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，
        因此数字签名能够验证信息的完整性。 

    数字签名有两种功效： 

       1、能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。 
       2、数字签名能确定消息的完整性
   
   数字证书：
        对于请求方来说，它怎么能确定它所得到的公钥一定是从目标主机那里发布的，而且没有被篡改过呢？这时候，我们需要有一个权威的值得信赖的第三方机构来统一对外发放主机机构的公钥

   证书包含哪些内容
       证书颁发机构的名称
       证书本身的数字签名
       证书持有者公钥
       证书签名用到的Hash算法
   
   其中数字签名的生成过程是：
      1、服务器公钥经过数字摘要算法生成hash值；
      2、hash值用认证机构的私钥加密，生成数字签名；
   
   浏览器或者手机默认都会内置CA根证书，其中根证书包含了CA的公钥
         对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A,然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，
         若不相等则是被篡改过的
         
  https中客户端验证公钥证书的过程，验证服务器的合法性
          1、客户端取出提前内置在手机内部的认证机构的公钥；
          2、用认证机构的公钥去解密公钥证书的数字签名，从而得到数字指纹；
         3、客户端对公钥证书的服务器公钥进行数字摘要算法，从而生成数字指纹
         4、对比客户端自己生成的数字摘要和解密得到的数字摘要是否一致

第七、什么是中间人攻击？如何避免
   
   http://ju.outofmemory.cn/entry/327252

   中间人攻击，就是攻击者插入到原本直接通信的双方，让双方以为还在直接跟对方通讯，但实际上双方的通信对方已变成了中间人，信息已经是被中间人获取或篡改
           SSL证书欺骗攻击
           SSL剥离攻击（SSLStrip），将HTTPS连接降级到HTTP连接

   防范HTTPS中间人攻击
      不要随意连入公共场合内的WiFi，或者使用未知代理服务器
      不要安装不可信或突然出现的描述文件，信任伪造的证书；（如某12306，在正规渠道下载系统以及浏览器）
      App内部需对服务器证书进行单独的对比校验，确认证书不是伪造的；
           查看证书是否过期
           服务器证书上的域名是否和服务器的实际域名相匹配
           校验证书链
           打包证书校验

第八、如何用Charles抓HTTPS的包？其中原理和流程是什么？
   
   https://www.jianshu.com/p/405f9d76f8c4

   HTTPS抓包的原理还是挺简单的，简单来说，就是Charles作为“中间人代理”，拿到了 服务器证书公钥 和 HTTPS连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，
   否则客户端就会“报警”并中止连接。

   1、客户端向服务器发起HTTPS请求
   2、Charles拦截客户端的请求，伪装成客户端向服务器进行请求
   3、服务器向“客户端”（实际上是Charles）返回服务器的CA证书
   4、Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥）
   5、客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）
   6、Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥）
   7、服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应
   8、Charles拦截服务器的响应，替换成自己的证书后发送给客户端
   至此，连接建立，Charles拿到了 服务器证书的公钥 和 客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。

第九、Socket与Http的区别
    
    Socket
       是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议，处于网络协议的传输层
       socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉

   HTTP协议：
      超文本传输协议，对应于应用层  ，HTTP协议是基于TCP连接的
      http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉

第十、TCP和UDP的区别与联系?

      TCP 传输控制协议
         面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)

      UDP 用户数据报协议
         面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快
         
        区别：
           1、tcp面向连接(如拨打电话先先拨号建立连接)，建立连接之前需要三次握手;udp是面向无连接，即发送数据之前不需要建立连接；
           2、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的；
           3、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付；
           4、 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等);
           5、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信；
           6、TCP首部开销20字节;UDP的首部开销小，只有8个字节
           7、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
           8、tcp每次传输少量数据，而udp可以传输大量数据；

第十一、http协议报文结构
       http请求报文结构：
            请求行、请求头、空行、请求内容
      请求行：
         由请求方法字段(post get等)、URL字段、协议版本字段三部分构成
      请求头：
         请求头由key/value对组成，请求头的作用主要用于通知服务端有关于客户端的请求信息
         请求头有：
            Accept-Language: 客户端可接受的自然语言
            Accept-Encoding: 客户端可接受的编码压缩格式
            Accept-Charset： 可接受的字符集
            Content-Type（标识请求内容的类型
            Content-Length（标识请求内容的长度）
      空行
         最后一个请求头之后就是空行，用于告诉服务器以下内容不再是请求头的内容
      请求内容
         请求内容主要用于POST请求，与POST请求方法配套的请求头一般有Content-Type（标识请求内容的类型）和Content-Length（标识请求内容的长度）



       http响应报文结构
            状态行、响应头、空行、响应内容

      状态行
         由HTTP协议版本、状态码、状态码描述三部分构成，它们之间由空格隔开
      响应头
         一般情况下，响应头会包含以下，甚至更多的信息
          Server： 包含服务器用来处理请求的软件信息及版本信息
          Vary：标识不可缓存的请求头列表
          Connection: 连接方式。

      空行
         最后一个响应头之后就是空行，用于告诉请求端以下内容不再是响应头的内容了
      响应内容
           服务端返回给请求端的文本信息

第十二、 DNS解析过程
     以www.163.com为例:
         1、客户端打开浏览器，输入一个域名。比如输入www.163.com，这时，客户端会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
         2、查询www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，
            就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
         3、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址；
         4、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，
            也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
            
         5、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，
            以备下次别的用户查询时，可以直接返回结果，加快网络访问

第十三、 CA（第三方认证机构）证书和数字签名(验证服务端有效性)
               https是http+ssl的结合体，http报文经过ssl层加密后交付给tcp层进行传输。
               ssl(安全套节层)先通过RSA(非对称加密)交互ASE(对称加密)的密钥，然后通过AES进行报文加密和解密。
              作用：
                     数字证书为了防止中间人攻击，掉包公钥
             数字签名证书包含的信息：
                    向CA提交公钥、组织信息、个人信息等信息并申请认证，认证通过后CA会向申请者颁发CA证书。证书中包含的信息有：
                    申请者公钥、申请者的组织信息和个人信息、签发机构、CA的信息、有效时间、证书序列号等信息的明文 和数字签名
              特别提醒：
                    CA自身的数字证书已经在我们的操作系统中安装好了 或者浏览器、手机上都有，CA的公钥也包含在其中
              数字签名怎样生产？
                    CA机构有两个密钥，CA私钥和CA公钥
                    CA机构将服务端的公钥通过散列哈希函数生产一个hash值，然后使用CA私钥进行加密处理，并与服务端的公钥绑一起，生成数字签名
              数字签名证书怎么去验证的是相应的服务端发过来的，是否是非法的证书？验证对方身份
              客户端使用CA公钥对数字证书上的签名进行验证，这个验证过程就是使用CA公钥对CA私钥加密的内容进行解密，将解密后的内容与服务端的公钥所生成的Hash值进行匹配，如果匹配成功，则说明该证书就是相应的服务端发过来的.
              
             参考文献： https://www.cnblogs.com/rinack/p/10743355.html
                                https://juejin.im/post/5ddb8a9d518825731f569aa6
第十五、解释一下三次握手和四次挥手过程
     三次握手
    1）第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号，请求建立连接的报文；ACK，确认收到请求连接的报文。
    2）第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
    3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），同步服务端也收到这个确认包AC，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
    四次握手
          1）客户端进程发出FIN(断开连接)报文，并且停止发送数据。此时，客户端进入FIN-WAIT-1（终止等待）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
          2）服务器收到连接释放报文，立即发出确认报文ACK，此时服务端就进入了CLOSE-WAIT（关闭等待）状态。   这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
     3）客户端同步收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送断开连接报文（在这之前还需要接受服务器发送的最后的数据）。
     4）等待服务器将最后的数据发送完毕后，就向客户端发送断开连接报文FIN和ack，此时为半关闭状态，服务器很可能又发送了一些数据，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
        5）客户端收到服务器的断开连接报文 后，必须发出确认ACK，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
     6）同步服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些
    
第十六、为什么连接的时候是三次握手，关闭的时候却是四次握手？
   答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手

第十七、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
答：
       1) MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间
    2)虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。
    3）Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接

第十八、如果已经建立了连接，但是客户端突然出现故障了怎么办？
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接
第十九、为什么不能用两次握手进行连接？

答：3次握手完成两个重要的功能，
      1）既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，
      2）也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
      三次握手改成仅需要两次握手，死锁是可能发生的！
       如果把三次握手改成两次握手，死锁是有可能发生的。假如Client发送了一个连接请求分组给Server，Server收到了这个分组，并且发送了确认应答分组。
         按照两次握手的协定，Server端认为已经建立连接了，可以进行发送数据。但是，如果Server的应答分组丢失了，Client将不知道Server是否准备好，
      甚至怀疑Server是否收到了自己的连接请求。在这种情况下，Client认为还未建立成功，将忽略Server发来的任何数据分组，只等待Server端的确认分组。而Server发出的分组超时后，
      重复发送同样的分组，这样就形成了死锁。
      
第二十、 网络传输和网络用户体验方面优化
       1） 传输文件用数据量小的json 或者protocol buffer,减少压缩网络数据
       2)  如果多次请求结果是相同，尽量使用缓存；
       3） 让用户可以取消耗时长的或者速度很慢的网络操作，设置合适的超时时间；
       4） 网络不可用时，不要尝试执行网络请求；
       5） 使用断点续传，否则网络不稳定时可能多次传输相同的内容；
       6） 批量传输，比如下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块的下载
       
第二十一 HTTP协议中GET和POST的区别
  1）GET在特定的浏览器和服务器对URL的长度是有限制的。 但是理论上是没有限制的
  2）POST不是通过URL进行传值，理论上不受限制。
  3）GET会把请求参数拼接到URL后面， 不安全
  4）POST把参数放到请求体里面， 会比GET相对安全一点， 但是由于可以窥探数据， 所以也不安全， 想更安全用加密。
  5）GET比POST的请求速度快。
    原因：Post请求的过程， 会现将请求头发送给服务器确认，然后才真正的发送数据， 而Get请求 过程会在链接建立后会将请求头和数据一起发送给服务器。 中间少了一步。
    所以get比post 快
  
 post的请求过程
          1）三次握手之后 第三次会把post请求头发送
          2）服务器返回100 continue响应
          3）浏览器开始发送数据
          4)  服务器返回200 ok响应
get请求过程
          1) 三次握手之后 第三次会发送get请求头和数据
          2) 服务器返回200 ok响应

第二十二、HTTPS和HTTP的区别
 
  https协议需要到CA申请证书，一般免费证书很少，需要交费。
  http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。
  http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
  http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

安全方面：
  1、认证用户或者服务器，确保数据发送到正确的客户机或者服务器
  2、加密数据以防止中途被窃取
  3、维护数据的完整性，确保数据在传输过程中不被改变


第二十三、UDP怎样实现可靠传输？

       传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
       
最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

    1）添加seq/ack机制，确保数据发送到对端
    2）添加发送和接收缓冲区，主要是用户超时重传。
    3）添加超时重传机制。
    
   详细说明：
      1、送端发送数据时，生成一个随机seq(序号)=x，然后每一片按照数据大小分配seq。
      2、数据到达接收端后接收端放入缓存，并发送一个ack(确认号)=x的包，表示对方已经收到了数据。
      3、发送端收到了ack包后，删除缓冲区对应的数据。
      4、时间到后，没有收到ack包后，定时任务检查是否需要重传数据。


第二十四、DNS过程 DNS劫持
   
   DNS 即域名系统（Domain Name Server），其主要用于将域名解析为对应的 IP 地址
   
   什么是DNS劫持？
      那DNS服务器会告诉你A网站的IP是A，B网站的IP是B，那假如你输入的A网站域名，但是他给你B的IP
   
   因此，在安全性方面来说，TCP/IP更具有优越性，DNS 的域名解析基于 UDP 协议实现，极易发生 DNS 劫持
   
   如何解决 DNS 劫持？
     HTTPDNS利用HTTP协议与DNS服务器交互，代替了传统的基于UDP协议的DNS交互，绕开了运营商的LocalDNS（本地 DNS 服务器），有效防止了域名劫持，提高域名解析效率

第二十五、 如何解决拆包粘包？

     tcp是无界的数据流，且协议本身无法避免粘包，拆包的发生，那我们只能在应用层数据协议上，加以控制。通常在制定传输数据时，可以使用如下方法：
     
          1）使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
          2）设置定长消息，服务端每次读取既定长度的内容作为一条完整消息；
          3）设置消息边界，服务端从网络流中按消息编辑分离出消息内容


第二十六、Tcp如何拥塞控制

  网络拥塞：
  
    在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做网络拥塞
    
    出现网络拥塞的条件：     对资源需求的总和 > 可用资源
        如：一根网线的带宽是50M，但是网络中的所有人传输的带宽已经大于50M了就会出现堵塞
        
 理想的拥塞控制：当网络上传输的数据包的流量超过了50M，路由器就会处理不过来大量的数据包时就会丢包，再传输过来的数据包就会直接扔掉。而且网络一点也不堵。
 实际的拥塞控制：为了避免出现拥塞的情况。如果出现了丢包的情况，路由器就会自动减缓发送速度和接受速度
 
 网络拥塞的解决方法：  慢开始算法、拥塞避免算法、快速重传、快速恢复
     
      慢开始和拥塞避免的工作原理：  先使用慢开始算法 然后 使用拥塞避免算法
      快重传和快恢复是配套使用的
      
 参考文献: https://blog.csdn.net/qq_44275045/article/details/106087331?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-2-106087331.nonecase&utm_term=tcp%E5%AE%9E%E7%8E%B0%E6%8B%A5%E5%A1%9E&spm=1000.2123.3001.4430
 
第二十七.网络很慢都会是哪些情况导致的？分别怎么解决
       1、访问的网站,服务器带宽窄或服版务器繁忙；
       2、电脑的权原因如电脑配置比较低或系统处理能力弱；
       3、可能是病毒或者木马等原因造成上网速度慢；
       4、使用路由器共享上网导致网速慢；
       5、设备出现工作不稳定；
       6、线路原因（如线路长、线路噪声较大、入户线质量不好、用户端线路改动等因素造成）。
       
第二十八 为啥网络要分层设计？
   1）各层之间相互独立：
         高层是不需要知道底层的功能是采取硬件技术来实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；
   
   2）易于实现和标准化：
            由于采取了规范的层次结构去组织网络功能与协议，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，
         使得复杂的计算机网络系统变得易于设计
         
   3）灵活性好：
      各层都可以采用最适当的技术来实现。只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响
